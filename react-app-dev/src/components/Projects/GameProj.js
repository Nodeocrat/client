import React from 'react';
import ScriptLoader from '@services/ScriptLoader';
import StatusText from '@lib/StatusText';
import Center from '@lib/Center';
import Button from 'react-bootstrap/lib/Button';

import position from '@styles/position.css';

export default class GameProj extends React.Component {
  constructor(props){
    super(props);

    ScriptLoader(
      ["https://cdn.socket.io/socket.io-1.2.0.js", "/drawscript.min.js"],
      () => this.setState({gameReady: true})
    );

    this.handleOnPlayAsGuest = this.handleOnPlayAsGuest.bind(this);
    this.handleOnPlay = this.handleOnPlay.bind(this);
    this.state = {
      gameReady: false,
      gameStarted: false,
      error: null,
      guestName: ""
    }
  }

  handleOnPlay(){
    const username = this.props.profile.username;
    const picUrl = this.props.profile.photoUrl;

    if(!username || !picUrl)
      return this.setState({
        error: "You must be logged in to play"
      });

    this.startGame(username, picUrl);
  }

  handleOnPlayAsGuest(){
    if(!this.state.guestName)
      return this.setState({
        error: "Please enter a guest name"
      });

    this.startGame(this.state.guestName);
  }

  startGame(username, inputPicUrl){
    const picUrl = inputPicUrl || "";
    window.startWebsocketSession(username, picUrl);

    this.setState({
      error: null,
      gameStarted: true
    });
  }

  render(){

    const canvasDisplay = this.state.gameStarted ? "block" : "none";
    const loginDisplay = this.state.gameStarted ? "none" : "block";
    return (
      <section>
        <div>
          <div style={{display: loginDisplay}}>
            <Center>
              <Button bsStyle="primary" onClick={this.handleOnPlay} disabled={!this.props.profile || !this.state.gameReady ? true : false} className={position.spanParent}>
                {`${this.state.gameReady ? "Play as signed in user" : "Loading..."}`}
              </Button>
              <br/><br/>
              <div className={position.center}>---- OR ----</div>
              <br/>
              <input className="form-control" placeholder="Guest name" onChange={e => this.setState({guestName: e.target.value})}/>
              <Button disabled={!this.state.gameReady} bsStyle="primary" onClick={this.handleOnPlayAsGuest} style={{minWidth: 100 + '%'}}>
                {`${this.state.gameReady ? "Play as guest" : "Loading..."}`}
              </Button>
            </Center>
            {this.state.error ? <StatusText className={position.center} type="error" text={this.state.error}/> : null}
          </div>
          <div style={{display: canvasDisplay}} id="game_container">
            <canvas style={{borderStyle: 'solid', borderWidth: 5 + 'px'}} id="canvas" width="800" height="800"></canvas>
            <div id="game_chat" style={{display: 'inline-block'}}>
              <ul id="messages"></ul>
              <input id="m" autoComplete="off"/>
              <button type="button" id="send-chat-msg">Send</button>
            </div>
          </div>
        </div>
        <hr/>
        <p>This mini-project was an idea I had to create a 'loopless' game engine for the server side for  multiplayer online games. The only third party library used is Socket.IO to aid with client-server communication. The rest is raw JavaScript. Most game engines for MMO's use game loops which is often a waste of resources, especially considering there are no graphics to update on the server. So instead of calculating movement and collisions through the traditional method (checking if objects 'cross over' each other 20-30 times per second), it uses an events-based system; objects are updated, and collisions are calculated (via mathematical interpolation) only when events are generated by users or generated from collisions.</p>

        <p>The collision engine was the main hurdle. First it calculates if a collision will occur in the first place, and if so, how long from now, but only provided the colliding objects remain on course. If any of the objects change size or direction then the 'not yet activated' collision event is cancelled. In theory, this should substantially reduce server load due to only needing to update objects, calculate collisions and send messages to each player as and when events occur, rather than 20-30 times per second as is usually the case with game loops.</p>

        <p>It works best with slower paced games with not too many players/NPCs where events will (on avg.) occur less than 20 times per second. If there are more than ~25 events occuring per second then it may start to perform worse than the traditional method. For now, I have only made it to work between circular objects. Objects of other shapes (maybe except ellipses) will likely require a completely different algorithm. Modifying the current algorithm to work with ellipses and an algorithm to work with any polygon (with all angles &lt;180 degrees) should be able to cover all cases.</p>

      </section>
    );
  }

};
