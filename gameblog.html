<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
</head>
<body>
  <h2>Shooty Balls (online multiplayer experiment)</h2>
  <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
  <script
    src="https://code.jquery.com/jquery-3.1.1.min.js"
    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
    crossorigin="anonymous"></script>
  <script src="/temp/drawscript.min.js"></script>
  <div id="login">
    <form id="login_form" action="">
      <input placeholder="Name" id="player-name" name="name"/>
      <button>Play</button>
    </form>
  </div>
  <div id="login-status"></div>
  <script>
    var name = document.getElementById('player-name').value;
    $('#login_form').submit(function(){
      startWebsocketSession(name, "myPicUrl");
      $('#m2').val('');
      return false;
    });
  </script>
  <div id="game_container" style="display:none">
    <canvas style="border-style: solid;border-width: 5px" id="canvas" width="800" height="800"></canvas>
    <div id="game_chat" style="display: inline-block">
      <ul id="messages"></ul>
      <form id="chat_form" action="">
        <input id="m" autocomplete="off"/><button>Send</button>
      </form>
    </div>
  </div>
  <br><br><br><br>
  <p>This mini-project was an idea I had to create a 'loopless' game engine for the server side for  multiplayer online games. The only third party library used is Socket.IO to aid with client-server communication. The rest is raw JavaScript. Most game engines for MMO's use game loops which is often a waste of resources, especially considering there are no graphics to update on the server. So instead of calculating movement and collisions through the traditional method (checking if objects 'cross over' each other 20-30 times per second), it uses an events-based system; objects are updated, and collisions are calculated (via mathematical interpolation) only when events are generated by users or generated from collisions (and NPCs in the future).</p>

  <p>The collision engine was the main hurdle. First it calculates if a collision will occur in the first place, and if so, how long from now, but only provided the colliding objects remain on course. If any of the objects change size or direction then the 'not yet activated' collision event is cancelled. In theory, this should substantially reduce server load due to only needing to update objects, calculate collisions and send messages to each player as and when events occur, rather than 20-30 times per second as is usually the case with game loops.</p>

  <p>It works best with slower paced games with not too many players/NPCs where events will (on avg.) occur less than 20 times per second. If there are more than ~25 events occuring per second then it may start to perform worse than the traditional method. For now, I have only made it to work between circular objects. Objects of other shapes (maybe except ellipses) will likely require a completely different algorithm. Modifying the current algorithm to work with ellipses and an algorithm to work with any polygon (with all angles &lt;180 degrees) should be able to cover all cases.</p>
  P.S. I didn't spend much time thinking of a name for it...
  <br>
  <br>
  <b>Summary of algorithm: </b>
  <p>When an event occurs (player shoot, player move, player resize), this triggers the update of every game object and the search for possible collisions. Updating game objects is trivial; just multiply its speed in the y and x directions by the difference in time since it was last updated:
    <code><br>var updateEntity = function(entityKey){<br>
      &emsp;var entity = entities[entityKey];<br>
      &emsp;var multiplier;<br>
      &emsp;if(playerInfo[entityKey].lastUpdated === undefined)<br>
      &emsp;{<br>
        &emsp;&emsp;multiplier = 0.0167;<br>
      &emsp;} else {<br>
        &emsp;&emsp;var diff = process.hrtime(playerInfo[entityKey].lastUpdated);<br>
        &emsp;&emsp;var deltaTimeNs = diff[0] * 1e9 + diff[1];<br>
        &emsp;&emsp;multiplier = deltaTimeNs/1000000000;<br>
      &emsp;}<br>
  <br>
      &emsp;entity.y += multiplier*(entity.dy);<br>
      &emsp;entity.x += multiplier*(entity.dx);<br>
      &emsp;playerInfo[entityKey].lastUpdated = process.hrtime();<br>
  <br>
      &emsp;//checks/validation<br>
      &emsp;if(entity.x > canvasWidth)<br>
        &emsp;&emsp;entity.x = canvasWidth;<br>
      &emsp;else if (entity.x < 0)<br>
        &emsp;&emsp;entity.x = 0;<br>
  <br>
      &emsp;if(entity.y > canvasHeight)<br>
        &emsp;&emsp;entity.y = canvasHeight;<br>
      &emsp;else if(entity.y < 0)<br>
        &emsp;&emsp;entity.y = 0;<br>
    }</code></p>
  <br>
  <p>To test for a collision between two objects, the algorithm is as follows (will provide explanations soon):
  <br><code>
    var testForCollision = function(causeEntityKey, causeEntity, destEntityKey, destEntity)<br>
    {<br>
      &emsp;var collX;<br>
      &emsp;var collY;<br>
      &emsp;var collT;<br>
  <br>
      &emsp;var x1 = causeEntity.x;<br>
      &emsp;var y1 = -causeEntity.y;<br>
      &emsp;var x2 = destEntity.x;<br>
      &emsp;var y2 = -destEntity.y;<br>
      &emsp;var r = causeEntity.radius + destEntity.radius; //radius<br>
      &emsp;var dx1 = (causeEntity.dx)/1000;<br>
      &emsp;var dy1 = -(causeEntity.dy)/1000;<br>
      &emsp;var dx2 = (destEntity.dx)/1000;<br>
      &emsp;var dy2 = -(destEntity.dy)/1000;<br>
  <br>
      &emsp;if(dx1 == 0 && dx2 == 0 && dy1 == 0 && dy2 == 0)<br>
        &emsp;&emsp;return;<br>
  <br>
      &emsp;var A = (dx1-dx2)*(dx1-dx2) + (dy1-dy2)*(dy1-dy2);<br>
      &emsp;var B = 2*(dx1-dx2)*(x1-x2) + 2*(dy1-dy2)*(y1-y2);<br>
      &emsp;var C = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) - r*r;<br>
      &emsp;var det = B*B - 4*A*C<br>
      &emsp;if(det < 0)<br>
        &emsp;&emsp;return;<br>
  <br>
      &emsp;collT = (-B - Math.sqrt(det))/(2*A);<br>
      &emsp;if(collT < 0)<br>
        &emsp;&emsp;return;<br>
      &emsp;collX = x1 + collT*dx1;<br>
      &emsp;collY = y1 + collT*dy1;<br>
  <br>
      &emsp;var collID = setTimeout(collision, collT, causeEntityKey, destEntityKey);<br>
      &emsp;if(!entToCollIDs.hasOwnProperty(causeEntityKey))<br>
        &emsp;&emsp;entToCollIDs[causeEntityKey] = [collID];<br>
      &emsp;else<br>
        &emsp;&emsp;entToCollIDs[causeEntityKey].push(collID);<br>
  <br>
      &emsp;if(!entToCollIDs.hasOwnProperty(destEntityKey))<br>
        &emsp;&emsp;entToCollIDs[destEntityKey] = [collID];<br>
      &emsp;else<br>
        &emsp;&emsp;entToCollIDs[destEntityKey].push(collID);<br>
    };

  </code></p>
</body>
