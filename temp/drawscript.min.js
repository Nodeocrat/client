'use strict';


// ## TEMPORARY UNTIL I CAN GET SHARED MODULES WORKING ON CLIENT ##
var Entity = class
{
    constructor(x, y, speed)
    {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.dx = 0;
        this.dy = 0;
        this.writable = true;
        this.type = null;
    }
}

var CircularEntity = class CircularEntity extends Entity
{
    constructor(x, y, speed, radius)
    {
        super(x, y, speed);
        this.radius = radius;
    }
}

var playerObj = class Player extends CircularEntity
{
    constructor(name, picUrl)
    {
        super(395, 395, 100, 10);
        this.name= name;
        this.type = "player";
        this.hit = 0;
        this.picUrl = picUrl;
    }
}

var Bullet = class Bullet extends CircularEntity
{
    constructor(originator, clickX, clickY)
    {
        super(0, 0, 300, 3);
        this.type = "bullet";
        this.player = originator;

        var theta;
        var diffX = clickX - originator.x;
        var diffY = originator.y - clickY;
        if(diffX >= 0)
            theta = Math.atan( diffY/diffX );
        else
            theta = Math.PI + Math.atan( diffY/diffX );
        this.y = originator.y - (originator.radius)*Math.sin(theta);
        this.x = originator.x + (originator.radius)*Math.cos(theta);
        this.dy = -(this.speed)*Math.sin(theta);
        this.dx = (this.speed)*Math.cos(theta);
    }
}

// 0. DECLARATIONS
var canvasInFocus = false;
var canvasClicked = false;
var animating = false;
var wraf;
var myName;
var SELF;
var bulletNo = 0;

var canvasWidth = 800;
var canvasHeight = 800;

var keysDown = {
	up : false,
	down : false,
	left : false,
	right : false,
	cancelAllKeys : function(){
		this.up=false; this.down=false; this.left=false; this.right=false;
	}
};

// 0.1: Game world variables
// class player: {int x, int y, int dx, int dy}
var entities = {};

var startWebsocketSession = function(username, myPicUrl){

	//1. SERVER INTERACTIONS
	var socket = io({path: '/api/socket.io'});
	socket.emit('login request', username, myPicUrl);
	$('#chat_form').submit(function(){
		socket.emit('chat message', $('#m').val());
		$('#m').val('');
		return false;
	});
	socket.on('welcome', function(entitiesOnServer, myNameOnServer, playerCon, bulletCon){
    console.log('booting up game');
		myName = myNameOnServer;
		entities = entitiesOnServer;
		SELF = entities[myName];
		canvasInFocus = true;

        // Initialize constructors
        //############# TO BE PASSED FROM SERVER ######
        //playerObj = eval(playerCon);
        //Bullet = eval(bulletCon);
        // ############################################

		initGame(socket);
	});
	//socket.on('disconnect'), hide/show elements and other cleanup operations (stopAnimating etc)
	socket.on('chat message', function(msg){
		$('#messages').append($('<li>').text(msg));
	});
	socket.on('connect', function(){
		$('#messages').append($('<li>').text("Welcome!"));
	});
	socket.on('player joined', function(player){
		entities[player.name] = player;
	});
	socket.on('player left', function(playerId){
		delete entities[playerId];
	});
	socket.on('move left', function(playerId){
		var player = entities[playerId];
		player.dx = -player.speed;
	});
	socket.on('stop move left', function(playerId, atX, atY){
		var player = entities[playerId];
		player.dx = 0;
		player.x = atX;
		player.y = atY;
	});
	socket.on('move right', function(playerId){
		var player = entities[playerId];
		player.dx = player.speed;
	});
	socket.on('stop move right', function(playerId, atX, atY){
		var player = entities[playerId];
		player.dx = 0;
		player.x = atX;
		player.y = atY;
	});
	socket.on('move up', function(playerId){
		var player = entities[playerId];
		player.dy = -player.speed;
	});
	socket.on('stop move up', function(playerId, atX, atY){
		var player = entities[playerId];
		player.dy = 0;
		player.x = atX;
		player.y = atY;
	});
	socket.on('move down', function(playerId){
		var player = entities[playerId];
		player.dy = player.speed;
	});
	socket.on('stop move down', function(playerId, atX, atY){
		var player = entities[playerId];
		player.dy = 0;
		player.x = atX;
		player.y = atY;
	});
	socket.on('player shot', function(bulletKey, originatorKey, clickX, clickY){
		var originator = entities[originatorKey];
		entities[bulletKey] = new Bullet(originator, clickX, clickY);
	});
	socket.on('collision', function(entityKey, destKey){

		//It's only a 'graphic' thing... so bulletEnt.dx = destEntity.dx, bulletEnt.dy = destEntity.dy;
		/*bulletEnt.dx = 0;
		bulletEnt.dy = 0;
		bulletEnt.x = x1;
		bulletEnt.y = y1;*/
		var entity = entities[entityKey];
		var dest = entities[destKey];
		if(entity.type == 'bullet')
		{
			if(dest.radius > 1)
			{
				entity.player.radius++;
				dest.radius--;
			}
			dest.hits++;
			delete entities[entityKey];
		}
		else
		{
			if(entity.radius > 1)
			{
				dest.player.radius++;
				entity.radius--;
			}
			entity.hits++;
			delete entities[destKey];
		}
	});
};

var initGame = function(socket){

	$('#login').fadeOut(100, function(){
		$('#game_container').fadeIn(100);
	});

	// Some useful variables
	var canvasElement = document.getElementById('canvas');
	var context = canvasElement.getContext('2d');

	window.onclick = function() {
		if(!canvasClicked){
			// If canvas has just been knocked out of focus, stop animating
			if(canvasInFocus)
				stopAnimating();
			canvasInFocus = false;
		} else { // canvas has been clicked

			// If canvas has just been brought into focus, call animate
			if(!canvasInFocus)
				window.requestAnimationFrame(animate);
			canvasInFocus = true;
			canvasClicked = false;
		}
	};

	canvasElement.onclick = function(event) {
		canvasClicked = true;

		var x, y;

		var canoffset = $(canvas).offset();
		x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft - Math.floor(canoffset.left);
		y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop - Math.floor(canoffset.top) + 1;


		/* For testing:
		$('#messages').append($('<li>').text("x: " + x + ", y: " + y));*/
		// upon click, print out the coordinates (append to some html elemlent)

		//SHOOT (needs own function)
		// TEST if I can do (bulletNo++)%1000
		var entityKey = "bullet|" + myName + "|" + bulletNo;
		bulletNo++;
		entities[entityKey] = new Bullet(SELF, x, y);
		socket.emit('player shot', x, y);

	};


	/*function(event){
		var totalOffsetX = 0;
		var totalOffsetY = 0;
		var canvasX = 0;
		var canvasY = 0;
		var currentElement = this;

		do{
		totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
		totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
		}
		while(currentElement = currentElement.offsetParent)

		canvasX = event.pageX - totalOffsetX;
		canvasY = event.pageY - totalOffsetY;

		$('#messages').append($('<li>').text("x: " + canvasX + ", y: " + canvasY));

		//return {x:canvasX, y:canvasY}
	};*/

	window.addEventListener("keydown", function (event) {

		if(!canvasInFocus || SELF === undefined)
			return;

		var eventCode = event.charCode || event.keyCode;   // Get the Unicode value

		switch (eventCode) {

			case 38: // up arrow
			case 87: // 'W'
				if(!keysDown.up && !keysDown.down) // key has just been pressed
				{
					SELF.dy = -1;
					keysDown.up = true;
					socket.emit('move up');
				}
				break;

			case 40: // down arrow
			case 83: // 'S'
				if(!keysDown.down && !keysDown.up)
				{
					SELF.dy = 1;
					keysDown.down = true;
					socket.emit('move down');
				}
				break;

			case 37: // left arrow
			case 65: // 'A'
				if(!keysDown.left && !keysDown.right)
				{
					SELF.dx = -1;
					keysDown.left = true;
					socket.emit('move left');
				}
				break;

			case 39: // right arrow
			case 68: // 'D'
				if(!keysDown.right && !keysDown.left)
				{
					SELF.dx = 1;
					keysDown.right = true;
					socket.emit('move right');
				}
				break;

			default:
			// Do nothing
		}
	}, true);

	window.addEventListener("keyup", function (event) {
		//if (event.defaultPrevented) {
		//	return; // Should do nothing if the key event was already consumed.
		//}

		if(!canvasInFocus)
			return;

		var eventCode = event.charCode || event.keyCode;   // Get the Unicode value

		switch (eventCode) {

			case 38: // up arrow
			case 87: // 'W'
				if(keysDown.up)
				{
					keysDown.up = false;
					SELF.dy = 0;
					socket.emit('stop move up');
				}
				break;

			case 40: // down arrow
			case 83: // 'S'
				if(keysDown.down)
				{
					SELF.dy = 0;
					keysDown.down = false;
					socket.emit('stop move up');
				}
				break;

			case 37: // left arrow
			case 65: // 'A'
				if(keysDown.left)
				{
					SELF.dx = 0;
					keysDown.left = false;
					socket.emit('stop move left');
				}
				break;

			case 39: // right arrow
			case 68: // 'D'
				if(keysDown.right)
				{
					SELF.dx = 0;
					keysDown.right = false;
					socket.emit('stop move right');
				}
				break;

			default:
			return; // Quit when this doesn't handle the key event.
		}

		// Consume the event for suppressing "double action".
		//event.preventDefault();
	}, true);

	var drawObj = {
		rectangle: function (player) {
			context.beginPath();
			context.rect(player.x, player.y, player.radius, player.height);
			context.fillStyle = 'black';
			context.fill();
			context.lineWidth = 1;
			context.strokeStyle = 'black';
			context.stroke();
		},

		circle: function (entity) {
      var radius = entity.radius;

      context.beginPath();

      /*if(entity.picUrl !== undefined && entity.picUrl){
        var thumbImg = document.createElement('img');

        thumbImg.src = entity.picUrl;
        context.arc(entity.x, entity.y, radius, 0, 2 * Math.PI, true);
        context.closePath();
        context.clip();

        context.drawImage(thumbImg, entity.x, entity.y, 50, 50);

        context.beginPath();
        context.arc(entity.x, entity.y, radius, 0, Math.PI * 2, true);
        context.clip();
        context.stroke();
      } else*/ {
        context.arc(entity.x, entity.y, radius, 0, 2 * Math.PI, false);
  	    context.fillStyle = (entity.type == "player") ? "rgb(" + 5*entity.hits + ",0,0)" : 'rgb(0,0,0)';
        context.fill();
        context.lineWidth = 1;
        context.strokeStyle = (entity.type == "player") ? "rgb(" + 5*entity.hits + ",0,0)" : 'rgb(0,0,0)';;
        context.stroke();
      }

			if(entity.hasOwnProperty("name")){ // Then it's a player entity
				context.font = "20px Arial";
				context.fillText(entity.name,entity.x - 10,entity.y + 30);
			}
		}
	};

	var lastTime = null;
	function animate(time){

		var deltaTime, multiplier;

		if(lastTime === null || lastTime === undefined)
		{
			multiplier = 0.5;
		} else {
			deltaTime = time - lastTime;
			multiplier = (deltaTime/1000);
		}

		// test not drawing players who don't move. will they disappear when not moving?
		// but I have to clear the Rect... >_>
		// Draw other players
		context.clearRect(0, 0, canvasElement.width, canvasElement.height);
		for (var entityId in entities) {
		  if (entities.hasOwnProperty(entityId)) {
  			var entity = entities[entityId];
  			var speedX;
  			var speedY;
  			if(entity.type == 'player' && entity.dy !== 0 && entity.dx !== 0)
  			{
  				speedX = Math.sqrt(0.5*(entity.speed)*(entity.speed))*((entity.dx)/Math.abs(entity.dx));
  				speedY = Math.sqrt(0.5*(entity.speed)*(entity.speed))*((entity.dy)/Math.abs(entity.dy));
  			}
  			else
  			{
  				speedX = entity.dx;
  				speedY = entity.dy;
  			}
  			entity.y += multiplier*speedY;
  			entity.x += multiplier*speedX;

  			if(entity.x > canvasWidth)
  			{
  				if(entity.type == 'bullet')
  					delete entities[entityId];
  				entity.x = canvasWidth;
  			}
  			else if (entity.x < 0 && entity.type == 'player')
  			{
  				if(entity.type == 'bullet')
  					delete entities[entityId];
  				entity.x = 0;
  			}

  			if(entity.y > canvasHeight)
  			{
  				if(entity.type == 'bullet')
  					delete entities[entityId];
  				entity.y = canvasHeight;
  			}
  			else if(entity.y < 0 && entity.type == 'player')
  			{
  				if(entity.type == 'bullet')
  					delete entities[entityId];
  				entity.y = 0;
  			}
  			drawObj.circle(entity);
		  }
		}

		lastTime = time;
		wraf = window.requestAnimationFrame(animate);
	};

	function stopAnimating(){
		window.cancelAnimationFrame(wraf);
		keysDown.cancelAllKeys();
		lastTime = null;
	};
	window.requestAnimationFrame(animate);
};
